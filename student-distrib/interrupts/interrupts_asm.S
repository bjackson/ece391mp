# interrupts.S
#
# vim:ts=4 expandtab

.data

# Jump table for system call ISR
syscall_jump: .long halt_asm, execute_asm, read_asm, write_asm, open_asm, close_asm, getargs_asm, vidmap_asm, set_handler_asm, sigreturn_asm
ret_value: .long 0

.text

# Macro simplifying generation of ISR linkage
# n: Index of the ISR
# ec: Boolean indicating whether the exception places an error code on the
#     stack. Default of 0 (no error code)
.macro ISR n ec=0
.globl isr\n
isr\n:
    cli
    .ifeq \ec
    pushl $0xdeadbeef
    .endif
    pushl $\n
    jmp isr_common
.endm

ISR 0 0
ISR 1 0
ISR 2 0
ISR 3 0
ISR 4 0
ISR 5 0
ISR 6 0
ISR 7 0
ISR 8 1
ISR 10 1
ISR 11 1
ISR 12 1
ISR 13 1
ISR 14 1
ISR 16 0
ISR 17 1
ISR 18 0
ISR 19 0

ISR 32 0
ISR 33 0
ISR 40 0

# void isr_common(uint32_t isr_index, uint32_t error_code);
#
# Function common to all ISRs
# Parameters:
#   isr_index: Index of the ISR
#   error_code: Optional error code pushed by some exceptions, 0 otherwise
# Returns: none
isr_common:
    cli                                # Disable further interrupts
    popl    %eax                       # eax: ISR index
    popl    %ecx                       # ecx: Error code

    pushl   %ebp
    movl    %esp, %ebp
    pushl   %ecx
    pushl   %eax
    call    isr_handler                # isr_handler(isr_index, error_code)
    add     $8, %esp

    sti                                # Re-enable interrupts

    leave
    iret

# void isr128(uint32_t syscall_num, ...);
#
# First function called for interrupts generated by a system call
# Parameters:
#   syscall_num: eax: The call number of the desired system call
#   ...
# Returns: Return value of the desired system call, or -1 if not found
.globl isr128
isr128:
    cli                                # Disable further interrupts
    pusha                              # Push all registers on the stack
    pushl   $0xDEADBEEF                # Push stack marker

    addl    $-1, %eax                  # syscal_num -= 1 (start counting at 0)

    cmpl    $9, %eax                   # if (syscall_num <= 9)
    jbe     isr128_valid_num

    addl    $4, %esp                   # Remove stack marker
    popa                               # Restore all registers from the stack
    movl    $-1, %eax                  # Return value: -1 (failed)
    jmp     isr128_return

isr128_valid_num:
    pushl   %ebp
    movl    %esp, %ebp                 # Setup new stack frame
    jmp     *syscall_jump(, %eax, 4)   # Jump to proper syscall

halt_asm:
    #movz   %bl, %bx
    pushw   %bx                        # bx: status
    call    sys_halt                   # sys_halt(status);
    addl    $2, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

execute_asm:
    pushl   %ebx                       # ebx: command
    call    sys_execute                # sys_execute(command);
    addl    $4, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

read_asm:
    pushl   %edx                       # edx: nbytes
    pushl   %ecx                       # ecx: buf
    pushl   %ebx                       # ebx: fd
    call    sys_read                   # sys_read(fd, buf, nbytes);
    addl    $12, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

write_asm:
    pushl   %edx                       # edx: nbytes
    pushl   %ecx                       # ecx: buf
    pushl   %ebx                       # ebx: fd
    call    sys_write                  # sys_write(fd, buf, nbytes);
    addl    $12, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

open_asm:
    pushl   %ebx                       # ebx: filename
    call    sys_open                   # sys_open(filename);
    addl    $4, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

close_asm:
    pushl   %ebx                       # ebx: fd
    call    sys_close                  # sys_close(fd);
    addl    $4, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

getargs_asm:
    pushl   %ecx                       # ecx: nbytes
    pushl   %ebx                       # ebx: buf
    call    sys_getargs                # sys_getargs(buf, nbytes);
    addl    $8, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

vidmap_asm:
    pushl   %ebx                       # ebx: screen_start
    call    sys_vidmap                 # sys_vidmap(screen_start);
    addl    $4, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

set_handler_asm:
    pushl   %ecx                       # ecx: handler_address
    pushl   %ebx                       # ebx: signum
    call    sys_set_handler
    addl    $8, %esp
    movl    %eax, ret_value
    jmp     isr128_sys_done

sigreturn_asm:
    call    sys_sigreturn
    movl    %eax, ret_value
    jmp     isr128_sys_done

isr128_sys_done:
    leave                              # Restore old stack frame
    add     $4, %esp                   # Remove stack marker
    popa                               # Restore all registers from the stack
    movl    ret_value, %eax            # eax: Return value

isr128_return:
    sti                                # Re-enable interrupts
    iret
